<document filename="extension.js"> 
const vscode = require('vscode'); const { WalletsWebviewProvider } = require('./src/providers/WalletsWebviewProvider'); const { registerMarkCommitCommand } = require('./src/commands/markCommit'); <p>/**</p> <ul> <li> <p>The main activate function for the extension. This is the entry point.</p> </li> <li> <p>All commands and providers must be registered here.</p> </li> <li> <p>@param {vscode.ExtensionContext} context */ function activate(context) {</p> <p>// 1. Register the Webview View Provider for the "walletsView" const walletsProvider = new WalletsWebviewProvider(context); context.subscriptions.push( vscode.window.registerWebviewViewProvider('walletsView', walletsProvider) );</p> <p>// 2. Register the "markCommit" command by calling the function from its module registerMarkCommitCommand(context, walletsProvider);</p> <p>// 3. Register the command to show the wallets sidebar let showSidebarCmd = vscode.commands.registerCommand('gitmark-ecash.showWalletsSidebar', () => { vscode.commands.executeCommand('workbench.view.extension.gitmark-ecash-wallets'); }); context.subscriptions.push(showSidebarCmd); }</p> </li> </ul> <p>function deactivate() {}</p> <p>module.exports = { activate, deactivate }; </p> <document filename="src/providers/WalletsWebviewProvider.js"> const vscode = require('vscode'); <p>// Instantiate the Chronik client once to be reused. // No longer needed in backend.</p> <p>class WalletsWebviewProvider { /**</p> <ul> <li>@param {vscode.ExtensionContext} context */ constructor(context) { this.context = context; this.webviewView = null; this.markCommitResolve = null; this.markCommitReject = null; console.log('WalletsWebviewProvider constructed'); }</li> </ul> <p>/**</p> <ul> <li> <p>Called by VS Code when the sidebar view is resolved.</p> </li> <li> <p>@param {vscode.WebviewView} webviewView */ resolveWebviewView(webviewView) { console.log('WalletsWebviewProvider.resolveWebviewView called'); this.webviewView = webviewView;</p> <p>webviewView.webview.options = { enableScripts: true }; webviewView.webview.html = this.getHtml();</p> <p>webviewView.webview.onDidReceiveMessage(async message => { console.log('WalletsWebviewProvider received message:', message); switch (message.command) { case 'selectWallet': { await this.context.globalState.update('gitmark-ecash.selectedWallet', message.name); break; } case 'markCommitResponse': { if (message.error) { if (this.markCommitReject) this.markCommitReject(new Error(message.error)); } else { if (this.markCommitResolve) this.markCommitResolve(message.txid); } this.markCommitResolve = null; this.markCommitReject = null; break; } } }); }</p> </li> </ul> <p>getHtml(errorContent = null) { return `</p> &#x3C;style> body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 1em; color: var(--vscode-editor-foreground); background-color: var(--vscode-editor-background); } .wallet { border: 1px solid var(--vscode-editorWidget-border); border-radius: 6px; padding: 0.5em; margin-bottom: 0.5em; cursor: pointer; } .wallet:hover { background-color: var(--vscode-list-hoverBackground); } .selected { background: var(--vscode-list-activeSelectionBackground); color: var(--vscode-list-activeSelectionForeground); } button { margin-top: 5px; margin-right: 0.5em; background-color: var(--vscode-button-background); color: var(--vscode-button-foreground); border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; } button:hover { background-color: var(--vscode-button-hoverBackground); } input { background-color: var(--vscode-input-background); color: var(--vscode-input-foreground); border: 1px solid var(--vscode-input-border); padding: 4px; border-radius: 4px; } .actions { margin-bottom: 1em; display: flex; gap: 0.5em; align-items: center; } .seed-modal { display: none; position: fixed; z-index: 99; left: 0; top: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.7); align-items: center; justify-content: center; } .seed-content { background: var(--vscode-editor-background); padding: 2em; border-radius: 8px; max-width: 400px; text-align: center; border: 1px solid var(--vscode-editorWidget-border); } &#x3C;/style> <div class="actions"> <button onclick="createWallet()">Create Wallet</button> <input id="importSeed" placeholder="12-word seed phrase" style="flex-grow: 1;"> <button onclick="importWallet()">Import</button> </div> <div id="wallets"></div> <div id="seedModal" class="seed-modal"> <div class="seed-content"> <h3 id="seedWalletName"></h3> <p id="seedPhrase" style="font-size:1.2em;word-break:break-word;"></p> <button onclick="closeSeedModal()">Close</button> </div> </div> ${errorContent ? errorContent : ''} &#x3C;script src="https://cdn.jsdelivr.net/npm/buffer@6.0.3/index.js">&#x3C;/script> &#x3C;script src="https://cdn.jsdelivr.net/npm/bip39@3.1.0/src/index.js">&#x3C;/script> &#x3C;script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js">&#x3C;/script> &#x3C;script src="https://cdn.jsdelivr.net/npm/cashaddrjs@0.4.4/dist/cashaddr.min.js">&#x3C;/script> &#x3C;script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.4.0/localforage.min.js">&#x3C;/script> &#x3C;script src="https://bundle.run/@noble/secp256k1@2.1.0">&#x3C;/script> &#x3C;script src="https://cdn.jsdelivr.net/npm/bip66@1.1.5/index.js">&#x3C;/script> &#x3C;script src="https://cdn.jsdelivr.net/npm/chronik-client@0.8.5/lib/index.inbrowser.min.js">&#x3C;/script> &#x3C;script> const vscode = acquireVsCodeApi(); const chronik = new ChronikClient('https://chronik.be.cash/xec'); const { secp256k1: nobleSecp } = nobleSecp256k1; const N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n; <p>function toBigIntBE(bytes) { let res = 0n; for (let b of bytes) res = res * 256n + BigInt(b); return res; }</p> <p>function toBytes32(big) { let bytes = new Uint8Array(32); for (let i = 31; i >= 0; i--) { bytes[i] = Number(big % 256n); big /= 256n; } return bytes; }</p> <p>async function hmacSHA512(keyBytes, dataBytes) { const key = await crypto.subtle.importKey( 'raw', keyBytes, {name: 'HMAC', hash: 'SHA-512'}, false, ['sign'] ); const sig = await crypto.subtle.sign('HMAC', key, dataBytes); return new Uint8Array(sig); }</p> <p>async function derivePrivateKey(mnemonic, path) { const seed = bip39.mnemonicToSeedSync(mnemonic); const seedBytes = new Uint8Array(seed); const masterKey = await hmacSHA512(new Uint8Array(Buffer.from('Bitcoin seed')), seedBytes); let priv = masterKey.slice(0, 32); let chain = masterKey.slice(32); const parts = path.slice(2).split('/').map(p => p.endsWith("'") ? parseInt(p.slice(0, -1)) + 0x80000000 : parseInt(p)); for (let index of parts) { const data = new Uint8Array(37); if (index >= 0x80000000) { data.set([0], 0); data.set(priv, 1); data.set(toLe4(index), 33); } else { const pub = nobleSecp.getPublicKey(priv, true); data.set(pub, 0); data.set(toLe4(index), 33); } const hmac = await hmacSHA512(chain, data); const IL = hmac.slice(0, 32); const IR = hmac.slice(32); let ki = (toBigIntBE(IL) + toBigIntBE(priv)) % N; if (ki === 0n) throw new Error('Invalid key'); priv = toBytes32(ki); chain = IR; } return priv; }</p> <p>async function getAddressFromMnemonic(mnemonic) { const priv = await derivePrivateKey(mnemonic, "m/44'/899'/0'/0/0"); const pub = nobleSecp.getPublicKey(priv, true); const sha = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(pub)); const rip = CryptoJS.RIPEMD160(sha); const wordArrayToByteArray = (wordArray) => { const byteArray = []; const words = wordArray.words; const sigBytes = wordArray.sigBytes; for (let i = 0; i &#x3C; sigBytes; i++) { const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) &#x26; 0xff; byteArray.push(bite); } return new Uint8Array(byteArray); }; const pkh = wordArrayToByteArray(rip); return cashaddr.encode('ecash', 'PUBKEYHASH', pkh); }</p> <p>async function createWallet() { const seed = bip39.generateMnemonic(); if (!bip39.validateMnemonic(seed)) return; const address = await getAddressFromMnemonic(seed); let wallets = await localforage.getItem('wallets') || []; const name = <code>Wallet ${wallets.length + 1}</code>; wallets.push({ name, seed, address }); await localforage.setItem('wallets', wallets); if (wallets.length === 1) { await localforage.setItem('selected', name); vscode.postMessage({ command: 'selectWallet', name }); } await loadWallets(); }</p> <p>async function importWallet() { const seed = document.getElementById('importSeed').value.trim(); document.getElementById('importSeed').value = ''; if (!seed || !bip39.validateMnemonic(seed)) { alert("Invalid seed phrase provided."); return; } const address = await getAddressFromMnemonic(seed); let wallets = await localforage.getItem('wallets') || []; const name = <code>Wallet ${wallets.length + 1}</code>; wallets.push({ name, seed, address }); await localforage.setItem('wallets', wallets); await loadWallets(); }</p> <p>async function selectWallet(name) { await localforage.setItem('selected', name); vscode.postMessage({ command: 'selectWallet', name }); await loadWallets(); }</p> <p>async function removeWallet(name) { let wallets = await localforage.getItem('wallets') || []; wallets = wallets.filter(w => w.name !== name); await localforage.setItem('wallets', wallets); let selected = await localforage.getItem('selected'); if (selected === name) { selected = wallets[0] ? wallets[0].name : null; await localforage.setItem('selected', selected); if (selected) vscode.postMessage({ command: 'selectWallet', name: selected }); } await loadWallets(); }</p> <p>function showSeed(name) { localforage.getItem('wallets').then(wallets => { const wallet = wallets.find(w => w.name === name); if (wallet) { document.getElementById('seedWalletName').innerText = wallet.name; document.getElementById('seedPhrase').innerText = wallet.seed; document.getElementById('seedModal').style.display = 'flex'; } }); }</p> <p>function closeSeedModal() { document.getElementById('seedModal').style.display = 'none'; }</p> <p>async function loadWallets() { let wallets = await localforage.getItem('wallets') || []; let selected = await localforage.getItem('selected'); const walletInfos = await Promise.all(wallets.map(async w => { let balance = 0; try { const utxosResult = await chronik.address(w.address).utxos(); if (utxosResult.utxos &#x26;&#x26; utxosResult.utxos.length > 0) { balance = utxosResult.utxos.reduce((acc, utxo) => acc + parseInt(utxo.value), 0); } } catch (e) { console.error(e); balance = 'Error'; } return { ...w, balance }; })); const container = document.getElementById('wallets'); if (walletInfos.length === 0) { container.innerHTML = '<i>No wallets found. Create or import one to get started.</i>'; return; } container.innerHTML = walletInfos.map(w => `</p> <div class="wallet ${w.name === selected ? &#x27;selected&#x27; : &#x27;&#x27;}" onclick="selectWallet(&#x27;${w.name}&#x27;)"> <b>${w.name}</b><br> <small>${w.address}</small><br> <span>Balance: <b>${w.balance}</b> sats</span><br> <button onclick="event.stopPropagation(); showSeed(&#x27;${w.name}&#x27;)">Show Seed</button> <button onclick="event.stopPropagation(); removeWallet(&#x27;${w.name}&#x27;)">Remove</button> </div> `).join(''); } <p>// Utility functions for markCommit function toLe4(n) { return new Uint8Array([n &#x26; 0xff, (n >> 8) &#x26; 0xff, (n >> 16) &#x26; 0xff, (n >> 24) &#x26; 0xff]); }</p> <p>function toLe8(v) { const arr = new Uint8Array(8); let val = v; for (let i = 0; i &#x3C; 8; i++) { arr[i] = Number(val &#x26; 0xffn); val >>= 8n; } return arr; }</p> <p>function varint(n) { if (n &#x3C; 0xfd) return new Uint8Array([n]); if (n &#x3C;= 0xffff) { return new Uint8Array([0xfd, n &#x26; 0xff, (n >> 8) &#x26; 0xff]); } // Assume small for this extension return new Uint8Array([0xfd, n &#x26; 0xff, (n >> 8) &#x26; 0xff]); }</p> <p>function toHex(bytes) { return Array.from(bytes, b => b.toString(16).padStart(2, '0')).join(''); }</p> <p>function fromHex(hex) { return new Uint8Array(hex.match(/../g).map(h => parseInt(h, 16))); }</p> <p>async function sha256(data) { return new Uint8Array(await crypto.subtle.digest('SHA-256', data)); }</p> <p>async function dsha256(data) { return await sha256(await sha256(data)); }</p> <p>async function handleMarkCommit(commitHash, selected) { const wallets = await localforage.getItem('wallets') || []; const wallet = wallets.find(w => w.name === selected); if (!wallet) throw new Error('No selected wallet'); const priv = await derivePrivateKey(wallet.seed, "m/44'/899'/0'/0/0"); const pub = nobleSecp.getPublicKey(priv, true); const decoded = cashaddr.decode(wallet.address); const pkh = decoded.payload; // Uint8Array const p2pkhScript = new Uint8Array([0x76, 0xa9, 0x14, ...pkh, 0x88, 0xac]); const utxosResult = await chronik.address(wallet.address).utxos(); if (!utxosResult.utxos || utxosResult.utxos.length === 0) throw new Error('No UTXOs found. Please fund this address.'); const utxos = utxosResult.utxos.map(u => ({ txidBytes: fromHex(u.outpoint.txid).reverse(), outIdx: u.outpoint.outIdx, value: BigInt(u.value), script: fromHex(u.outputScript) })); const totalSat = utxos.reduce((a, u) => a + u.value, 0n); const gitmarkBytes = new Uint8Array('gitmark'.split('').map(c => c.charCodeAt(0))); const hashBytes = new Uint8Array(commitHash.split('').map(c => c.charCodeAt(0))); const opReturnScript = new Uint8Array([0x6a, gitmarkBytes.length, ...gitmarkBytes, hashBytes.length, ...hashBytes]); let outputs = [{value: 0n, script: opReturnScript}]; // Estimate size const n = utxos.length; let estimatedSize = 10 + n * 148 + (8 + 1 + opReturnScript.length) + 34; let fee = BigInt(estimatedSize); let changeValue = totalSat - fee; const dust = 546n; if (changeValue &#x3C; dust) { outputs = [{value: 0n, script: opReturnScript}]; fee = totalSat; } else { outputs.push({value: changeValue, script: p2pkhScript}); } const version = 1; const locktime = 0; const sequence = 0xffffffff; const inputs = utxos.map(u => ({txidBytes: u.txidBytes, outIdx: u.outIdx, value: u.value, scriptSig: new Uint8Array(), sequence})); const hashPrevouts = await dsha256(new Uint8Array([].concat(...inputs.map(i => [...i.txidBytes, ...toLe4(i.outIdx)])))); const hashSequence = await dsha256(new Uint8Array([].concat(...inputs.map(() => toLe4(sequence))))); const hashOutputs = await dsha256(new Uint8Array([].concat(...outputs.map(o => [...toLe8(o.value), ...varint(o.script.length), ...o.script])))); const sighashType = 0x41; for (let i = 0; i &#x3C; n; i++) { const input = inputs[i]; const outpoint = new Uint8Array([...input.txidBytes, ...toLe4(input.outIdx)]); const preimage = new Uint8Array([].concat( ...toLe4(version), ...hashPrevouts, ...hashSequence, ...outpoint, ...varint(p2pkhScript.length), ...p2pkhScript, ...toLe8(utxos[i].value), ...toLe4(sequence), ...hashOutputs, ...toLe4(locktime), ...toLe4(sighashType) )); const digest = await sha256(preimage); const signature = nobleSecp.signSync(digest, priv, { lowS: true }); const r = signature.slice(0, 32); const s = signature.slice(32); const der = BIP66.encode(r, s); const fullSig = new Uint8Array([...der, sighashType]); const scriptSig = new Uint8Array([fullSig.length, ...fullSig, pub.length, ...pub]); input.scriptSig = scriptSig; } let txBytes = [].concat( ...toLe4(version), ...varint(n), ...inputs.flatMap(inp => [...inp.txidBytes, ...toLe4(inp.outIdx), ...varint(inp.scriptSig.length), ...inp.scriptSig, ...toLe4(inp.sequence)]), ...varint(outputs.length), ...outputs.flatMap(o => [...toLe8(o.value), ...varint(o.script.length), ...o.script]), ...toLe4(locktime) ); const rawTx = new Uint8Array(txBytes); const txHex = toHex(rawTx); const broadcastResult = await chronik.broadcastTx(txHex); return broadcastResult.txid; }</p> <p>window.addEventListener('message', async event => { const message = event.data; if (message.command === 'markCommit') { try { const txid = await handleMarkCommit(message.commitHash, message.selected); vscode.postMessage({ command: 'markCommitResponse', txid }); } catch (err) { vscode.postMessage({ command: 'markCommitResponse', error: err.message }); } } });</p> <p>localforage.ready().then(() => loadWallets()).catch(console.error); &#x3C;/script></p> `; } } <p>module.exports = { WalletsWebviewProvider }; </p> <document filename="src/commands/markCommit.js"> const vscode = require('vscode'); <p>function registerMarkCommitCommand(context, walletsProvider) { let markCommitCommand = vscode.commands.registerCommand('gitmark-ecash.markCommit', async function () { const gitExtension = vscode.extensions.getExtension('vscode.git').exports; const api = gitExtension.getAPI(1);</p> <p>if (api.repositories.length === 0) { vscode.window.showErrorMessage('No Git repository found.'); return; }</p> <p>const repo = api.repositories[0]; const head = repo.state.HEAD;</p> <p>if (!head || !head.commit) { vscode.window.showErrorMessage('No commits found in this repository.'); return; }</p> <p>const commitHash = head.commit;</p> <p>const selectedWallet = context.globalState.get('gitmark-ecash.selectedWallet');</p> <p>if (!selectedWallet) { vscode.window.showErrorMessage('No wallet selected. Please select a wallet from the Gitmark view.'); return; }</p> <p>if (!walletsProvider.webviewView) { vscode.window.showErrorMessage('Please open the eCash Wallets sidebar to mark the commit.'); return; }</p> <p>vscode.window.withProgress({ location: vscode.ProgressLocation.Notification, title: "Gitmarking commit...", cancellable: false }, async (progress) => { try { progress.report({ message: <code>Marking commit ${commitHash.substring(0, 12)}...</code> });</p> <p>const txid = await new Promise((resolve, reject) => { walletsProvider.markCommitResolve = resolve; walletsProvider.markCommitReject = reject; walletsProvider.webviewView.webview.postMessage({ command: 'markCommit', commitHash, selected: selectedWallet }); });</p> <p>const successMsg = <code>Commit ${commitHash.substring(0, 12)} marked successfully!</code>; vscode.window.showInformationMessage(successMsg, 'View on Block Explorer').then(selection => { if (selection === 'View on Block Explorer') { vscode.env.openExternal(vscode.Uri.parse(<code>https://explorer.e.cash/tx/${txid}</code>)); } });</p> <p>} catch (error) { console.error(error); vscode.window.showErrorMessage(<code>Gitmark failed: ${error.message}</code>); } }); });</p> <p>context.subscriptions.push(markCommitCommand); }</p> <p>module.exports = { registerMarkCommitCommand }; </p> <document filename="package.json"> { "name": "gitmark-ecash", "displayName": "Gitmark for eCash", "description": "Marks git commits on the eCash (XEC) blockchain.", "version": "0.5.1", "publisher": "mediaprophet", "icon": "images/logo.png", "engines": { "vscode": "^1.85.0" }, "main": "./extension.js", "contributes": { "commands": [ { "command": "gitmark-ecash.markCommit", "title": "Gitmark: Mark latest commit on eCash" }, { "command": "gitmark-ecash.showWalletsSidebar", "title": "Gitmark: Show Wallets Sidebar" } ], "menus": { "scm/title": [ { "when": "scmProvider == 'git'", "command": "gitmark-ecash.markCommit", "group": "navigation" } ] }, "viewsContainers": { "activitybar": [ { "id": "gitmark-ecash-wallets", "title": "eCash Wallets", "icon": "codicon:credit-card" } ] }, "views": { "gitmark-ecash-wallets": [ { "id": "walletsView", "name": "Wallets", "icon": "codicon:credit-card" } ] } }, "scripts": { "lint": "eslint .", "test": "node ./test/runTest.js" }, "devDependencies": { "@types/mocha": "^10.0.6", "@types/node": "18.x", "@types/vscode": "^1.85.0", "@vscode/test-electron": "^2.3.8", "eslint": "^8.57.1", "glob": "^8.1.0", "mocha": "^10.2.0", "typescript": "^5.3.3" }, "dependencies": { "chronik-client": "^0.8.5" } } </document> <p>The package.json dependencies have been reduced to only what's necessary for the backend (chronik-client is kept but not used; you can remove it if desired). Private keys (seeds) are now stored exclusively in the webview using localforage and are never sent to or stored in the extension's global state. The transaction signing and broadcasting logic has been moved to the webview to ensure security.</p></document></document></document>



